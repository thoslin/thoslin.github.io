<html>
  <head>
    
      <title>Tom Lin's thoughts and writings</title>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <script type="text/javascript">
      WebFontConfig = {
        google: { families: [ 'Droid+Sans::latin' ] }
      };
      (function() {
        var wf = document.createElement('script');
        wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
          '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
        wf.type = 'text/javascript';
        wf.async = 'true';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(wf, s);
      })();
    </script>
    <link rel="stylesheet" type="text/css" href="/stylesheets/screen.css">
  </head>
  <body>
    <header id="spine">
    <h1 id="hey">
        <a href="/">Hi,<br/> I'm Tom.</a>
    </h1>
    <p class="description">
    I'm a Python web developer living in Shanghai. This is my personal website and blog.
</p>
    <div id="profiles">
    <a href="/">Blog</a>
    <span>&nbsp;&middot;&nbsp;</span>
    <a target="_blank" href="http://github.com/thoslin">Github</a>
    <span>&nbsp;&middot;&nbsp;</span>
    <a target="_blank" href="http://twitter.com/thoslin">Twitter</a>
</div>
    <div id="recent">
    <h5 class="heading">Recent <a href="/archive/" id="full-archive">(Full archive &rarr;)</a></h5>
    <ol>
        
        <li>
          <a href="/cassandra-a-journey-of-upgrade/">Cassandra: A Journey of Upgrade</a>
        </li>
        
        <li>
          <a href="/ramble-on-java-and-session/">Ramble on Java &amp; Session</a>
        </li>
        
        <li>
          <a href="/cassandra-create-a-cluster-on-your-local-machine/">Cassandra: Create a cluster on your local machine</a>
        </li>
        
        <li>
          <a href="/simple-guide-to-install-statsd-and-graphite/">Simple Guide to Install StatsD and Graphite</a>
        </li>
        
        <li>
          <a href="/impostor-syndrome/">Impostor syndrome</a>
        </li>
        
    </ol>
</div>
    <h4>Site designed by <a target="_blank" href="https://github.com/orourkedesign">@orourkedesign</a>.
</header>
    <section id="content">
      
  
  
  <article>
  <div class="meta">
    <time>18 Sep 2015</time>
  </div>
  <h1>Cassandra: A Journey of Upgrade</h1>
  
  <p>For the past few couple months, a huge burden on my shoulder had been upgrading our Cassandra cluster from 1.2.6 to 2.1. I&rsquo;ve been investing a lot of working hours to figure out the solution. Now that it has been done, I feel it is worthwhile to write down the whole experience.</p>

<h3>Why Upgrade?</h3>

<p>Actually the imperative reason is that we need transaction support in one of our services. And Cassandra 2.0 introduced a new feature called light-weight transaction, although it is light-weight, it somehow can fix our issue.</p>

<p>Besides that, there are also a couple of new features we can benefit from the upgrade:</p>

<ul>
<li>Improved native transport protocol. We&rsquo;re quite interested in the more stream requests over one connection. This is introduced in 2.1.</li>
<li>Automatically paging support. We have queries for a large number of rows, this at a big chance will cause RPC timeout. Our workaround is to implements our own paging mechanism.</li>
<li>Better counter. It is well known that Cassandra&rsquo;s distributed counter is buggy. They improve it in 2.1</li>
</ul>


<h3>Infrastructure</h3>

<ul>
<li>10 nodes on production. 3 nodes on other stacks.</li>
<li>Replication factor: 3</li>
<li>Replication strategy: Simple strategy</li>
<li>Consistency level: CL.ONE for both read and write.</li>
</ul>


<h3>Upgrade Path</h3>

<h4>Driver upgrade</h4>

<p>We&rsquo;re using a fairly old driver Cassandra called Pycassa, which is no longer maintained. And it is based on thrift protocol, which is deprecated/ditched in the version 3, so all the new and good stuff on the native protocol has nothing to do with Pycassa. Very naturally we switched to the recommended/official driver maintained by the Datastax.</p>

<p>Internally we don&rsquo;t have a layer for Cassandra, so refactoring is a lot of pain. We have to replace all the code usages of Pycassa among all services, and carefully update all unit tests.</p>

<p>We also bumped into some issues when deploying with the new driver:</p>

<ul>
<li><a href="https://datastax-oss.atlassian.net/browse/PYTHON-239">High CPU utilization when using asyncore event loop</a>. By now, this is not been fixed yet, so avoid using asycore, instead use gevent/libev.</li>
<li><a href="https://datastax-oss.atlassian.net/browse/PYTHON-364">Reconnect not initiated when all nodes are down</a></li>
<li><a href="https://datastax-oss.atlassian.net/browse/PYTHON-325">ConstantReconnectionPolicy does not work with max_attempts=None</a></li>
<li><a href="https://datastax-oss.atlassian.net/browse/PYTHON-237">Can&rsquo;t detect gevent monkey patch when using with uwsgi &mdash;gevent-monkey-patch option</a>. If you are monkey patch in uwsgi, use -gevent-early-monkey option.</li>
</ul>


<p>The driver upgrade is not as smooth as I thought. A lot of back and forth happened and it took us almost two month or so to ship the upgrade.</p>

<h4>No rolling upgrade?</h4>

<p>Rolling upgrade should be a default option for a cluster upgrade. But unfortunately it is not supported between major versions of Cassandra. As it is documented <a href="https://github.com/apache/cassandra/blob/trunk/NEWS.txt">here</a>. We thought about workarounds. Like building a new Cluster and syncing data between two clusters. But building a new cluster is not our option due to some &ldquo;policy&rdquo;, so we decided that we can tolerate some downtime, and that also means we will update each Cassandra instance in place.</p>

<h4>Data backup and restore</h4>

<p>It&rsquo;s important to have a backup of the data. In case something goes wrong, we can go back to the save point. When doing data backup, we demand that all services that access Cassandra should be stopped and keep data untouched during the process.</p>

<p>Below is a typical structure of one of  our Cassandra nodes:</p>

<p>/mnt/cassandra/</p>

<p>── commitlog_directory</p>

<p>── data_file_directories</p>

<p>&ldquo;data_file_directories&rdquo; is where Cassandra data files live, our goal is to backup this directory. We&rsquo;ll do a &lsquo;<a href="http://docs.datastax.com/en/cassandra/2.0/cassandra/tools/toolsDrain.html">nodetool drain</a>&rsquo; on the node, which will flush all memtables to data files. After that We&rsquo;ll pack data_file_directories into one tarball and upload it to the cloud(to prevent disk failure of node). So we&rsquo;ll have two copies of data.</p>

<p>Procedure:</p>

<ol>
<li>Drain the node</li>
<li>Clear snapshots</li>
<li>Shut down the node</li>
<li>Pack data files into a tarball.</li>
<li>Upload the tarball to swift</li>
</ol>


<p>If something goes wrong and we want to abort the upgrade and go back to the old version. We simply retrieve the old data and unpack it to the Cassandra data file directory.</p>

<p>The backup and restore procedure are automated by Ansible scripts.</p>

<h4>Upgrade</h4>

<p>Upgrade directly from current version 1.2.6 to 2.1 is not possible. Since pre-2.0 SSTables are not supported by 2.1. A direct upgrade to 2.1, Cassandra would fail to start and following error would be raised:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>java.lang.RuntimeException: Incompatible SSTable found. Current version ka is unable to read file: /var/lib/cassandra/data/system/schema_keyspaces/system-schema_keyspaces-ic-1. Please run upgradesstables.
</span><span class='line'>        at org.apache.cassandra.db.ColumnFamilyStore.createColumnFamilyStore(ColumnFamilyStore.java:443) ~[apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.db.ColumnFamilyStore.createColumnFamilyStore(ColumnFamilyStore.java:420) ~[apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.db.Keyspace.initCf(Keyspace.java:327) ~[apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.db.Keyspace.&lt;init&gt;(Keyspace.java:280) ~[apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.db.Keyspace.open(Keyspace.java:122) ~[apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.db.Keyspace.open(Keyspace.java:99) ~[apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.db.SystemKeyspace.checkHealth(SystemKeyspace.java:558) ~[apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.service.CassandraDaemon.setup(CassandraDaemon.java:214) [apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.service.CassandraDaemon.activate(CassandraDaemon.java:443) [apache-cassandra-2.1.1.jar:2.1.1]
</span><span class='line'>        at org.apache.cassandra.service.CassandraDaemon.main(CassandraDaemon.java:532) [apache-cassandra-2.1.1.jar:2.1.1]</span></code></pre></td></tr></table></div></figure>


<p>So we upgraded to 2.0.0 and run upgradesstables command to upgrade SSTables. After that, we then upgrade from 2.0.0 to 2.1.</p>

<p>Cassandra has an internal <a href="http://www.bajb.net/2013/03/cassandra-sstable-format-version-numbers/">version for SSTables</a>. During the upgrade, sstable version will be bumping from:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ic (1.2.6) --&gt; ja (2.0.0) --&gt; ka(2.1.3)</span></code></pre></td></tr></table></div></figure>


<p>Procedure:</p>

<ol>
<li>Install Cassandra 2.0.0. Before starting, set num_tokens to 1. The new version uses virtual nodes by default.</li>
<li>Upgrade SSTables</li>
<li>Drain and stop the node</li>
<li>Remove commit logs</li>
<li>Install Cassandra 2.1.3</li>
<li>Upgrade SSTables (Not necessary)</li>
<li>Bring back all services</li>
</ol>


<p>The procedure looks simple and clear. While we had couple issue when doing test upgrade:</p>

<ul>
<li>After upgrade from 1.2.6 to 2.0.0, Cassandra cannot start due to out of memory. It turns out when Cassandra starts, it would read the key cache. OutOfMemory when reading key cache seems to be a <a href="http://cassandra-user-incubator-apache-org.3065146.n2.nabble.com/OOM-while-reading-key-cache-td7591267.html">known issue</a>. The solution is to <a href="http://mail-archives.apache.org/mod_mbox/cassandra-user/201307.mbox/%3C7B902431-9666-4D21-9324-8632BB6358F8@thelastpickle.com%3E">clean up caches</a> before starting up.</li>
<li>During the upgrade to 2.1, drain failed. It is a <a href="https://issues.apache.org/jira/browse/CASSANDRA-6374">bug</a> and said to be fixed in 2.0.3. So we upgrade to 2.0.3 instead.</li>
</ul>


<h4>Data consistency</h4>

<p>How to ensure data are not corrupted during the upgrade? I think this should be guaranteed by Cassandra. However when doing upgrade testing, we have a script to dump all Cassandra data before and after the upgrade to ensure data are not touched. This step is taken away when we&rsquo;re doing actual upgrade.</p>

</article>
  <div class="sep">&nbsp;</div>

  
  
  <article>
  <div class="meta">
    <time>08 Sep 2015</time>
  </div>
  <h1>Ramble on Java &amp; Session</h1>
  
  <p>Recently I&rsquo;ve been working on some Java stuff, from JSP, Spring MVC to Hibernate. It&rsquo;s actually not such a smooth and comfortable switch from Python to Java, especially when building a website with frameworks. A hello world page would takes more efforts in Java comparing to Python. Part of the reason may be I&rsquo;m quite a novice in the Java world, the learning curve of which is steeper than that of Python.</p>

<p>However the previous experience on Python web development is not for nothing, to some extent, it helps me understand the concepts in Java web. I always try to find equivalents in Python when coming across a new thing in Java. For example, Tomcat/Jetty, the Java servlet container, is somewhat equivalent to WSGI containers like uWSGI, and servlet, is somewhat equivalent to WSGI. Hibernate is something like Django ORM/Sqlalchemy. Spring AOP is like decorators. Spring Controllers is somewhat like Flask views. Although there&rsquo;s some concepts I can&rsquo;t find analogies to, like dependencies injection, IoC. Python seems to be able to achieve those with the language support.</p>

<p>During my exploration into Java web, I started building a very simple <a href="https://github.com/thoslin/spring-todo">todo list</a> app on Spring MVC, just to get my hands dirty with this famed framework. When working on a simple login function for the app, I came to think how Spring handle sessions. Down below, I use Spring Security for authentication and authorization. Again, I find it is somewhat equivalent to auth/session app in Django.</p>

<p>As I recalled, Django supports couple <a href="https://docs.djangoproject.com/en/1.8/topics/http/sessions/#configuring-the-session-engine">session backends</a>, by default it uses DB to store sessions. When clients first visited, a new session is created in the session table, where all session data for that single session is stored and session keys are returned in cookies. With this session key in cookie, separate requests can share data and relate to each other, as they&rsquo;re in a same session. When clients are authenticated, a flag is set in the session to prevent further authentication.</p>

<p>Apparently this is not how Spring security session works, as they don&rsquo;t have any table created. Another session implementation I remembered is the one from Flask, which uses <a href="http://werkzeug.pocoo.org/docs/0.10/contrib/securecookie/#module-werkzeug.contrib.securecookie">secure cookie</a> from werkzeug. This implementation stores user&rsquo;s session data(no session key in this case) in cookie. Session data is serialized and a checksum of the data is appended before sending back to client. Checksum is checked to make sure data is not tampered. However after inspecting the cookie, there&rsquo;s a only a cookie called JSESSIONID, which should be the id of a session, and skimming through some code of Spring security, this doesn&rsquo;t look like the approach adapted.</p>

<p>So where the hell is session stored in Spring? After some googling around, I learned that A) Session is a low level api implemented in servlet container B) Tomcat stores session in memory! A little bit surprised, session is not persisted. Nevertheless in respect of performance, in memory store is absolute a winner. But the problem is also obvious, What if server crashes? What if there&rsquo;s a cluster of servers? How does it scale?</p>

<p>Then I learned that, to distribute session with a cluster of servers, Tomcat supports <a href="https://tomcat.apache.org/tomcat-6.0-doc/cluster-howto.html">session replication</a>. And there&rsquo;s also a solution called &ldquo;<a href="http://stackoverflow.com/questions/10494431/sticky-and-non-sticky-sessions">sticky session</a>&rdquo;. A term never heard of before. But in fact it is just a load balance strategy that route the same client to the same server so that the client is sticked to that server, the session is kept. However as to the scenario that single server crashed, I&rsquo;m not sure how Tomcat failed over that. Maybe just failed that, session is never meant to store persistent data.</p>

<p>Tracing back to the time when I was working with Django, We tend to use a different session store other than database, such as Memcache or Redis. Rereading the Django documentation on session, I found it also supports <a href="https://docs.djangoproject.com/en/1.8/topics/http/sessions/#using-cached-sessions">local memory</a>, but not recommended. Tomcat also supports different <a href="http://tomcat.apache.org/tomcat-5.5-doc/config/manager.html">persistent storage</a>.</p>

<p>So I&rsquo;ve mumbled so many things about session. That is what really get me started on this post. But what I was trying to convey is that, when switching to different tech stack, surprise is not bad, as we may find that our understanding of things is not that accurate or simply wrong. But just like the analogies I make, the philosophy behind things might be the same. Dig that.</p>

</article>
  <div class="sep">&nbsp;</div>

  
  
  <article>
  <div class="meta">
    <time>02 Jun 2015</time>
  </div>
  <h1>Cassandra: Create a cluster on your local machine</h1>
  
  <p>This post will guide you through how to create a Cassandra cluster of multiple node on a local machine.</p>

<p>First, Let&rsquo;s grab a copy of Cassandra, I&rsquo;m using a Ubuntu 12.04 box and gonna go with Cassandra 1.2.19.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir test_cluster
</span><span class='line'>cd test_cluster
</span><span class='line'>wget http://www.us.apache.org/dist/cassandra/1.2.19/apache-cassandra-1.2.19-bin.tar.gz
</span><span class='line'>tar xzf apache-cassandra-1.2.19-bin.tar.gz</span></code></pre></td></tr></table></div></figure>


<p>The package already includes everything needed to start a Cassandra node. You can start it by sudo bin/cassandra. It will use all the defaults to start a Cassandra node. With data under /var/lib. with no initial token. We&rsquo;re not going to do that. As we&rsquo;re creating multiple nodes. Each node gonna will have its own directory and configurations. That said,
all nodes will share the same binaries comes within this tarball, but with different confs and directories for logs, data, commit logs.</p>

<p>We will build a directory structure like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>node1
</span><span class='line'>├── bin
</span><span class='line'>├── commitlog
</span><span class='line'>├── conf
</span><span class='line'>├── data
</span><span class='line'>├── logs
</span><span class='line'>└── saved_caches</span></code></pre></td></tr></table></div></figure>


<p>Now let&rsquo;s set up our first node:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd test_cluster
</span><span class='line'>mkdir node1
</span><span class='line'>cd node1
</span><span class='line'>mkdir commitlog data logs save_caches
</span><span class='line'>cp -r ../apache-cassandra-1.2.19/bin .
</span><span class='line'>cp -r ../apache-cassandra-1.2.19/conf .</span></code></pre></td></tr></table></div></figure>


<p>We need to make some customizations before we bootstrap this node. And before we jump into that, we should generate initial_token for each node, unless you prefer virtual node, which is recommended. Anyway I use the following command to generate tokens:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>python -c 'print [str(((2**64 / number_of_tokens) * i) - 2**63) for i in range(number_of_tokens)]'</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;re going to create two nodes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>python -c 'print [str(((2**64 / 2) * i) - 2**63) for i in range(2)]'  
</span><span class='line'>['-9223372036854775808', '0']</span></code></pre></td></tr></table></div></figure>


<p>Now we can proceed with the setup:</p>

<h4>conf/cassandra.yaml</h4>

<p>The configuration file for Cassandra. There are couple items needs to be changed:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>commitlog_directory: /home/tom/test_cluster/node1/commitlog
</span><span class='line'>data_file_directories:
</span><span class='line'>- /home/tom/test_cluster/node1/data
</span><span class='line'>initial_token: -9223372036854775808
</span><span class='line'>listen_address: 127.0.0.1
</span><span class='line'>rpc_address: 127.0.0.1
</span><span class='line'>saved_caches_directory: /home/tom/test_cluster/node1/saved_caches</span></code></pre></td></tr></table></div></figure>


<h4>bin/cassandra.in.sh</h4>

<p>The so-called include script. For seting environment variables needed by the start script bin/cassandra. We&rsquo;ll change following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CASSANDRA_HOME=/home/tom/test_cluster/apache-cassandra-1.2.19
</span><span class='line'>CASSANDRA_CONF=/home/tom/test_cluster/node1/conf</span></code></pre></td></tr></table></div></figure>


<p>CASSANDRA_HOME is where the binaries live, CASSANDRA_CONF is where the conf for the node lives.</p>

<h4>conf/log4j-server.properies</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>log4j.appender.R.File=/home/tom/test_cluster/node1/logs/system.log</span></code></pre></td></tr></table></div></figure>


<p>Now we&rsquo;re all set to start the node. Remember to set the CASSANDRA_INCLUDE to our cassandra.in.sh so that Cassandra will search the right place for confs.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CASSANDRA_INCLUDE=/home/tom/test_cluster/node1/bin/cassandra.in.sh /home/tom/test_cluster/node1/bin/cassandra -f</span></code></pre></td></tr></table></div></figure>


<p>OK. If everything goes soothly, you should have the node up and running. Now Let&rsquo;s set up a second node. Nothing special. Just repeat the above steps. Use &ldquo;node2&rdquo; instead of &ldquo;node1&rdquo; when changing configurations. And use a different listen_address and rpc_address:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>commitlog_directory: /home/tom/test_cluster/node2/commitlog
</span><span class='line'>data_file_directories:
</span><span class='line'>- /home/tom/test_cluster/node2/data
</span><span class='line'>initial_token: 0
</span><span class='line'>listen_address: 127.0.0.2
</span><span class='line'>rpc_address: 127.0.0.2
</span><span class='line'>saved_caches_directory: /home/tom/test_cluster/node2/saved_caches</span></code></pre></td></tr></table></div></figure>


<p>And remember to make an extra modification to <strong>conf/cassandra-env.sh</strong> to avoid port conflicts. Change default JMX_PORT to anything other than default 7199.
And start the node. The node will automatically join the ring.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>~/test_cluster/node1 » bin/nodetool ring
</span><span class='line'>Note: Ownership information does not include topology; for complete information, specify a keyspace
</span><span class='line'>Datacenter: datacenter1
</span><span class='line'>==========
</span><span class='line'>Address    Rack        Status State   Load            Owns                Token                                      
</span><span class='line'>                                                                          0                                          
</span><span class='line'>127.0.0.1  rack1       Up     Normal  13.99 KB        50.00%              -9223372036854775808                      
</span><span class='line'>127.0.0.2  rack1       Up     Normal  10.71 KB        50.00%              0              </span></code></pre></td></tr></table></div></figure>


<p>Alright. You got a cluster running on your local machine!</p>

<p>Reference:
<a href="http://wiki.apache.org/cassandra/GettingStarted">http://wiki.apache.org/cassandra/GettingStarted</a></p>

</article>
  <div class="sep">&nbsp;</div>

<div id="full-archive">
    <a href="/archive/">View the full archive &rarr;</a>
</div>
    </section>
    <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-42896888-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </body>
</html>